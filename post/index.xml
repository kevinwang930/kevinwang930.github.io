<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Kevin wang's blog</title><link>https://kevinwang930.github.io/post/</link><description>Recent content in Posts on Kevin wang's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 27 Mar 2024 14:39:29 +0800</lastBuildDate><atom:link href="https://kevinwang930.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring微服务架构与实现</title><link>https://kevinwang930.github.io/post/spring/mvc/</link><pubDate>Wed, 27 Mar 2024 14:39:29 +0800</pubDate><guid>https://kevinwang930.github.io/post/spring/mvc/</guid><description>&lt;p>本文记录spring微服务架构与实现细节&lt;/p></description></item><item><title>Config</title><link>https://kevinwang930.github.io/post/linux/config/</link><pubDate>Sun, 24 Mar 2024 21:52:14 +0800</pubDate><guid>https://kevinwang930.github.io/post/linux/config/</guid><description>&lt;p>本文记录bash启动时加载配置文件的方式&lt;/p></description></item><item><title>Function Pointer</title><link>https://kevinwang930.github.io/post/cpp/function-pointer/</link><pubDate>Sat, 23 Mar 2024 22:27:40 +0800</pubDate><guid>https://kevinwang930.github.io/post/cpp/function-pointer/</guid><description>&lt;p>本文记录cpp函数指针及其调用方式&lt;/p></description></item><item><title>JVM 启动流程</title><link>https://kevinwang930.github.io/post/jvm-startup/</link><pubDate>Wed, 20 Mar 2024 00:46:56 +0800</pubDate><guid>https://kevinwang930.github.io/post/jvm-startup/</guid><description>&lt;p>本文记录jvm启动流程&lt;/p></description></item><item><title>Jvm Interpreter Internals</title><link>https://kevinwang930.github.io/post/jvm-bytecode-interpreter/</link><pubDate>Tue, 19 Mar 2024 00:01:52 +0800</pubDate><guid>https://kevinwang930.github.io/post/jvm-bytecode-interpreter/</guid><description>this article tries to analyze the internal implementation of jvm interpreter</description></item><item><title>Algorithms</title><link>https://kevinwang930.github.io/post/algorithm/</link><pubDate>Sat, 02 Mar 2024 16:55:12 +0800</pubDate><guid>https://kevinwang930.github.io/post/algorithm/</guid><description>1. Sort 1.1 Bubble sort a simple sorting algorithm that repeatedly steps through the input list element by element, comparing the current element with the one after it, swapping their values if needed. These passes through the list are repeated until no swaps have to be performed during a pass, meaning that the list has become fully sorted.
1.2 insertion sort participant &amp;#34;Caller&amp;#34; participant &amp;#34;InsertionSort&amp;#34; as insort Caller -&amp;gt; insort : sort(array) loop for i = 1 to length(array) - 1 insort -&amp;gt; insort : key = array[i] insort -&amp;gt; insort : j = i - 1 loop while j &amp;gt;= 0 and array[j] &amp;gt; key insort -&amp;gt; insort : array[j + 1] = array[j] insort -&amp;gt; insort : j = j - 1 end insort -&amp;gt; insort : array[j + 1] = key end Caller &amp;lt;-- insort : array sorted @enduml 1.</description></item><item><title>数据结构-树</title><link>https://kevinwang930.github.io/post/tree/</link><pubDate>Sun, 25 Feb 2024 23:56:03 +0800</pubDate><guid>https://kevinwang930.github.io/post/tree/</guid><description>1. Binary tree each node has at most 2 child nodes called left node and right node.
1.1 Complete Binary Tree definitions:
binary tree every level is completely filled except the last level all nodes in the last level are as far left as possible Complete Binary tree can be stored in array
root node is arr[0] for the ith node parent node arr[(i-1)/2] left child node arr[(2*i)+1] right child node arr[(2*i)+2] title complete binary tree usecase A usecase B usecase C usecase D usecase E usecase F A --&amp;gt; B A --&amp;gt; C B --&amp;gt; D B --&amp;gt; E C --&amp;gt; F 1.</description></item><item><title>Concurrency in Java</title><link>https://kevinwang930.github.io/post/java-concurrency-lock/</link><pubDate>Sun, 25 Feb 2024 01:57:48 +0800</pubDate><guid>https://kevinwang930.github.io/post/java-concurrency-lock/</guid><description>&lt;h1 id="concurrency-utilities-in-java">Concurrency Utilities in Java&lt;/h1>
&lt;p>The concurrency utilities packages provide a powerful, extensible framework of high-performance threading utilities such as thread pools and blocking queues. This package frees the programmer from the need to craft these utilities by hand, in much the same manner the collections framework did for data structures. Additionally, these packages provide low-level primitives for advanced concurrent programming.&lt;/p></description></item><item><title>java collections internals</title><link>https://kevinwang930.github.io/post/java-collections/</link><pubDate>Sat, 24 Feb 2024 19:16:25 +0800</pubDate><guid>https://kevinwang930.github.io/post/java-collections/</guid><description>1. Collections A collection is an object that represents a group of objects (such as the classic Vector class). A collections framework is a unified architecture for representing and manipulating collections, enabling collections to be manipulated independently of implementation details.
1.1 Collection interfaces java.util.collection java.util.Set java.util.SortedSet java.util.NavigableSet java.util.Queue java.util.concurrent.BlockingQueue java.util.concurrent.TransferQueue java.util.Deque java.util.concurrent.BlockingDeque java.util.map and offspring java.util.SortedMap java.util.NavigableMap java.util.concurrent.ConcurrentMap java.util.concurrent.ConcurrentNavigableMap title:collection interface Collection&amp;lt;E&amp;gt; { int size() boolean isEmpty() contains() Iterator&amp;lt;E&amp;gt; iterator() T[] toArray(T[] a) boolean add(E e) boolean remove(Object o) default boolean removeIf(Predicate&amp;lt;?</description></item><item><title>Java Nio</title><link>https://kevinwang930.github.io/post/java-nio/</link><pubDate>Sat, 24 Feb 2024 16:11:41 +0800</pubDate><guid>https://kevinwang930.github.io/post/java-nio/</guid><description>Java NIO 1. stream api package io { class InputStream { read(byte[]) mark(int) close() reset() skip() } class OutputStream() { write(byte[]) flush() close() } } package nio() { interface Channel { close() isOpen() } abstract class FileChannel { open(Path) read(ByteBuffer) write(ByteBuffer) lock() close() } Channel o-- FileChannel } netty event loop i/o processor custom task channel wrapper of socket
channel pipeline channel handler</description></item><item><title>Spring internals</title><link>https://kevinwang930.github.io/post/spring-boot/</link><pubDate>Tue, 09 Jan 2024 23:29:20 +0800</pubDate><guid>https://kevinwang930.github.io/post/spring-boot/</guid><description>本文记录springBoot 内部实现
1. Environment abstraction Environment Interface is an abstraction in container that models 2 key aspects of application environment.
profile A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active
properties Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Map objects, and so on</description></item><item><title/><link>https://kevinwang930.github.io/post/java/tomcat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://kevinwang930.github.io/post/java/tomcat/</guid><description/></item></channel></rss>