<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Kevin wang's blog</title><link>https://kevinwang930.github.io/post/</link><description>Recent content in Posts on Kevin wang's blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 02 Mar 2024 16:55:12 +0800</lastBuildDate><atom:link href="https://kevinwang930.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Algorithms</title><link>https://kevinwang930.github.io/post/algorithm/</link><pubDate>Sat, 02 Mar 2024 16:55:12 +0800</pubDate><guid>https://kevinwang930.github.io/post/algorithm/</guid><description>1. Sort 1.1 Bubble sort a simple sorting algorithm that repeatedly steps through the input list element by element, comparing the current element with the one after it, swapping their values if needed. These passes through the list are repeated until no swaps have to be performed during a pass, meaning that the list has become fully sorted.
1.2 insertion sort participant &amp;#34;Caller&amp;#34; participant &amp;#34;InsertionSort&amp;#34; as insort Caller -&amp;gt; insort : sort(array) loop for i = 1 to length(array) - 1 insort -&amp;gt; insort : key = array[i] insort -&amp;gt; insort : j = i - 1 loop while j &amp;gt;= 0 and array[j] &amp;gt; key insort -&amp;gt; insort : array[j + 1] = array[j] insort -&amp;gt; insort : j = j - 1 end insort -&amp;gt; insort : array[j + 1] = key end Caller &amp;lt;-- insort : array sorted @enduml 1.</description></item><item><title>数据结构-树</title><link>https://kevinwang930.github.io/post/data-structure/</link><pubDate>Sun, 25 Feb 2024 23:56:03 +0800</pubDate><guid>https://kevinwang930.github.io/post/data-structure/</guid><description>&lt;h1 id="1--tree">1. Tree&lt;/h1>
&lt;h2 id="11-binary-tree">1.1 Binary tree&lt;/h2>
&lt;p>each node has at most 2 child nodes called left node and right node.&lt;/p>
&lt;h3 id="111-complete-binary-tree">1.1.1 Complete Binary Tree&lt;/h3>
&lt;p>definitions:&lt;/p>
&lt;ol>
&lt;li>binary tree&lt;/li>
&lt;li>every level is completely filled except the last level&lt;/li>
&lt;li>all nodes in the last level are as far left as possible&lt;/li>
&lt;/ol>
&lt;p>Complete Binary tree can be stored in array&lt;/p>
&lt;ol>
&lt;li>root node is arr[0]&lt;/li>
&lt;li>for the ith node
&lt;ol>
&lt;li>parent node arr[(i-1)/2]&lt;/li>
&lt;li>left child node arr[(2*i)+1]&lt;/li>
&lt;li>right child node arr[(2*i)+2]&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code class="language-plantuml" data-lang="plantuml">title complete binary tree
usecase A
usecase B
usecase C
usecase D
usecase E
usecase F

A --&amp;gt; B
A --&amp;gt; C
B --&amp;gt; D
B --&amp;gt; E
C --&amp;gt; F
&lt;/code>&lt;/pre>&lt;h3 id="112-binary-search-tree">1.1.2 Binary Search Tree&lt;/h3>
&lt;p>BST, or binary sorted tree&lt;/p>
&lt;ol>
&lt;li>binary tree&lt;/li>
&lt;li>key of each node is greater than the keys of left subtree&lt;/li>
&lt;li>key of each node is smaller than the keys of right subtree&lt;/li>
&lt;/ol>
&lt;h3 id="113-balanced-search-tree">1.1.3 Balanced Search Tree&lt;/h3>
&lt;ol>
&lt;li>Binary Search Tree&lt;/li>
&lt;li>for height balanced tree the height of n items is guaranteed to be &lt;code>o(logn)&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="12-red-black-tree">1.2 Red Black Tree&lt;/h1>
&lt;ol>
&lt;li>binary search tree&lt;/li>
&lt;li>every node is either red or black&lt;/li>
&lt;li>all NIL nodes are considered black&lt;/li>
&lt;li>A red node does not have a red child&lt;/li>
&lt;li>Every path from a given node to any of its descendant NIL nodes goes through same number of black nodes&lt;/li>
&lt;li>if a node N has exactly one child, it must be a red child, because if it were black, its NIL descendants would sit at a different black depth than N&amp;rsquo;s NIL child. violation 5&lt;/li>
&lt;/ol>
&lt;p>红黑书作为二叉搜索树，使用旋转保持树的平衡。&lt;/p>
&lt;h1 id="2-tree-based-data-structures">2. Tree based data Structures&lt;/h1></description></item><item><title>Concurrency in Java</title><link>https://kevinwang930.github.io/post/java-concurrency-lock/</link><pubDate>Sun, 25 Feb 2024 01:57:48 +0800</pubDate><guid>https://kevinwang930.github.io/post/java-concurrency-lock/</guid><description>&lt;h1 id="concurrency-utilities-in-java">Concurrency Utilities in Java&lt;/h1>
&lt;p>The concurrency utilities packages provide a powerful, extensible framework of high-performance threading utilities such as thread pools and blocking queues. This package frees the programmer from the need to craft these utilities by hand, in much the same manner the collections framework did for data structures. Additionally, these packages provide low-level primitives for advanced concurrent programming.&lt;/p></description></item><item><title>java collections internals</title><link>https://kevinwang930.github.io/post/java-collections/</link><pubDate>Sat, 24 Feb 2024 19:16:25 +0800</pubDate><guid>https://kevinwang930.github.io/post/java-collections/</guid><description>1. Collections A collection is an object that represents a group of objects (such as the classic Vector class). A collections framework is a unified architecture for representing and manipulating collections, enabling collections to be manipulated independently of implementation details.
1.1 Collection interfaces java.util.collection java.util.Set java.util.SortedSet java.util.NavigableSet java.util.Queue java.util.concurrent.BlockingQueue java.util.concurrent.TransferQueue java.util.Deque java.util.concurrent.BlockingDeque java.util.map and offspring java.util.SortedMap java.util.NavigableMap java.util.concurrent.ConcurrentMap java.util.concurrent.ConcurrentNavigableMap interface Collection&amp;lt;E&amp;gt; { int size() boolean isEmpty() contains() Iterator&amp;lt;E&amp;gt; iterator() T[] toArray(T[] a) boolean add(E e) boolean remove(Object o) default boolean removeIf(Predicate&amp;lt;?</description></item><item><title>Java Nio</title><link>https://kevinwang930.github.io/post/java-nio/</link><pubDate>Sat, 24 Feb 2024 16:11:41 +0800</pubDate><guid>https://kevinwang930.github.io/post/java-nio/</guid><description>Java NIO 1. stream api package io { class InputStream { read(byte[]) mark(int) close() reset() skip() } class OutputStream() { write(byte[]) flush() close() } } package nio() { interface Channel { close() isOpen() } abstract class FileChannel { open(Path) read(ByteBuffer) write(ByteBuffer) lock() close() } Channel o-- FileChannel } netty event loop i/o processor custom task channel wrapper of socket
channel pipeline channel handler</description></item><item><title>Spring boot 启动流程</title><link>https://kevinwang930.github.io/post/my-first-post/</link><pubDate>Tue, 09 Jan 2024 23:29:20 +0800</pubDate><guid>https://kevinwang930.github.io/post/my-first-post/</guid><description>1. 概述 class SpringApplication { WebApplicationType webApplicationType List&amp;lt;ApplicationContextInitializer&amp;lt;?&amp;gt;&amp;gt; initializers List&amp;lt;ApplicationListener&amp;lt;?&amp;gt;&amp;gt; listeners ApplicationContextFactory applicationContextFactory ConfigurableApplicationContext run(String... args) void prepareContext() } interface ConfigurableApplicationContext { void refresh() } SpringApplication --&amp;gt; ConfigurableApplicationContext:create</description></item></channel></rss>